import fs from 'node:fs/promises';
import path from 'node:path';
import os from 'node:os';
import { performance } from 'node:perf_hooks';
import { spawn } from 'node:child_process';

import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';

const DEFAULT_CLIENT_INFO = { name: 'dexter-codex-bridge', version: '0.1.0' };
const DEFAULT_COMMAND = process.env.CODEX_BRIDGE_COMMAND || 'codex';
const DEFAULT_ARGS = [
  'mcp',
  'serve',
  '--config', 'sandbox="read-only"',
  '--config', 'approval_policy="never"',
  '--config', 'tools.web_search=true',
];
const DEFAULT_HOME = process.env.CODEX_BRIDGE_HOME || path.join(os.tmpdir(), 'dexter-codex-bridge');
const SOURCE_HOME = process.env.CODEX_HOME || path.join(os.homedir(), '.codex');
const DEFAULT_REQUEST_TIMEOUT_MS = Number(process.env.CODEX_BRIDGE_REQUEST_TIMEOUT_MS || 120_000);
const DEFAULT_MAX_TOTAL_TIMEOUT_MS = Number(process.env.CODEX_BRIDGE_MAX_TOTAL_TIMEOUT_MS || 1_800_000);
const LOG_PREFIX = '[codex-bridge]';

function log(...args) {
  if (process.env.CODEX_BRIDGE_SILENT === '1') return;
  console.log(LOG_PREFIX, ...args);
}

function warn(...args) {
  if (process.env.CODEX_BRIDGE_SILENT === '1') return;
  console.warn(LOG_PREFIX, ...args);
}

function error(...args) {
  console.error(LOG_PREFIX, ...args);
}

async function ensureDir(dir) {
  await fs.mkdir(dir, { recursive: true, mode: 0o700 });
}

async function safeCopy(src, dest) {
  try {
    const data = await fs.readFile(src);
    await fs.writeFile(dest, data, { mode: 0o600 });
  } catch (err) {
    if (err && err.code === 'ENOENT') return;
    throw err;
  }
}

async function ensureConfig(dest) {
  try {
    await fs.access(dest);
  } catch (err) {
    if (err && err.code === 'ENOENT') {
      const contents = [
        '# Autogenerated Codex config for Dexter bridge',
        'model = "gpt-5-codex"',
        'model_reasoning_effort = "high"',
        'approval_policy = "never"',
        'sandbox_mode = "danger-full-access"',
        '',
      ].join('\n');
      await fs.writeFile(dest, contents, { mode: 0o600 });
    } else {
      throw err;
    }
  }
}

function extractFirstText(result) {
  if (!result || !Array.isArray(result.content)) return '';
  const block = result.content.find((entry) => entry?.type === 'text' && entry.text);
  return block ? String(block.text) : '';
}

function simplifyEvent(entry) {
  if (!entry || typeof entry !== 'object') return null;
  const { id = null, msg = null } = entry;
  if (!msg || typeof msg !== 'object') return null;
  const simplified = { type: msg.type || null };
  if (id) simplified.id = id;
  if (msg.delta) simplified.delta = msg.delta;
  if (msg.text) simplified.text = msg.text;
  if (msg.message) simplified.message = msg.message;
  if (msg.reason) simplified.reason = msg.reason;
  if (msg.info) simplified.info = msg.info;
  if (msg.rate_limits) simplified.rate_limits = msg.rate_limits;
  if (msg.model) simplified.model = msg.model;
  if (msg.reasoning_effort) simplified.reasoning_effort = msg.reasoning_effort;
  if (msg.session_id) simplified.session_id = msg.session_id;
  if (msg.rollout_path) simplified.rollout_path = msg.rollout_path;
  return simplified;
}

function summarizeEvents(events, { fallbackConversationId } = {}) {
  const summary = {
    sessionId: fallbackConversationId || null,
    model: null,
    reasoningEffort: null,
    rolloutPath: null,
    reasoning: null,
    agentMessage: null,
    tokenUsage: null,
    rateLimits: null,
    timeline: [],
  };

  const reasoningChunks = [];
  const messageChunks = [];

  for (const entry of events) {
    const msg = entry?.msg;
    if (!msg) continue;
    summary.timeline.push(simplifyEvent(entry));
    switch (msg.type) {
      case 'session_configured':
        summary.sessionId = msg.session_id || summary.sessionId;
        summary.model = msg.model || summary.model;
        summary.reasoningEffort = msg.reasoning_effort || summary.reasoningEffort;
        summary.rolloutPath = msg.rollout_path || summary.rolloutPath;
        break;
      case 'agent_reasoning_delta':
        if (msg.delta) reasoningChunks.push(msg.delta);
        break;
      case 'agent_reasoning':
        if (msg.text) reasoningChunks.push(msg.text);
        break;
      case 'agent_message_delta':
        if (msg.delta) messageChunks.push(msg.delta);
        break;
      case 'agent_message':
        if (msg.message) summary.agentMessage = msg.message;
        break;
      case 'token_count':
        summary.tokenUsage = msg.info?.total_token_usage || msg.info || summary.tokenUsage;
        summary.rateLimits = msg.rate_limits || summary.rateLimits;
        break;
      default:
        break;
    }
  }

  if (!summary.reasoning && reasoningChunks.length) {
    summary.reasoning = reasoningChunks.join('');
  }
  if (!summary.agentMessage && messageChunks.length) {
    summary.agentMessage = messageChunks.join('');
  }

  return summary;
}

class CodexBridge {
  constructor(options = {}) {
    this.options = {
      command: options.command || DEFAULT_COMMAND,
      args: Array.isArray(options.args) && options.args.length ? options.args : DEFAULT_ARGS,
      home: options.home || DEFAULT_HOME,
      clientInfo: options.clientInfo || DEFAULT_CLIENT_INFO,
      requestTimeoutMs: options.requestTimeoutMs || DEFAULT_REQUEST_TIMEOUT_MS,
      maxTotalTimeoutMs: options.maxTotalTimeoutMs || DEFAULT_MAX_TOTAL_TIMEOUT_MS,
    };
    this.client = null;
    this.transport = null;
    this.queue = Promise.resolve();
    this.homePrepared = false;
  }

  async prepareHome() {
    if (this.homePrepared) return;
    const home = this.options.home;
    await ensureDir(home);
    await safeCopy(path.join(SOURCE_HOME, 'auth.json'), path.join(home, 'auth.json'));
    await safeCopy(path.join(SOURCE_HOME, 'version.json'), path.join(home, 'version.json'));
    await ensureDir(path.join(home, 'sessions'));
    await ensureDir(path.join(home, 'log'));
    await ensureConfig(path.join(home, 'config.toml'));
    this.homePrepared = true;
  }

  async ensureClient() {
    if (this.client) return this.client;
    await this.prepareHome();

    const transport = new StdioClientTransport({
      command: this.options.command,
      args: this.options.args,
      env: {
        ...process.env,
        CODEX_HOME: this.options.home,
      },
      stderr: 'pipe',
    });

    if (transport.stderr) {
      transport.stderr.on('data', (chunk) => {
        const text = chunk.toString();
        if (text.trim()) {
          log('stderr', text.trim());
        }
      });
    }

    transport.onclose = () => {
      warn('transport closed');
      this.client = null;
      this.transport = null;
    };
    transport.onerror = (err) => {
      error('transport error', err);
    };

    const client = new Client(this.options.clientInfo, {
      capabilities: {
        tools: {},
        logging: {},
        prompts: {},
        resources: {},
      },
    });

    client.onerror = (err) => {
      error('client error', err);
    };

    await client.connect(transport, {
      timeout: this.options.requestTimeoutMs,
      maxTotalTimeout: this.options.maxTotalTimeoutMs,
    });

    this.transport = transport;
    this.client = client;
    log('connected');
    return client;
  }

  async withLock(fn) {
    const next = this.queue.then(() => fn());
    this.queue = next.catch(() => {});
    return next;
  }

  async runToolCall(name, args, extra = {}) {
    const run = async () => {
      const client = await this.ensureClient();
      const events = [];
      const previousHandler = client.fallbackNotificationHandler;
      client.fallbackNotificationHandler = (notification) => {
        try {
          if (notification?.method === 'codex/event' && notification.params) {
            events.push(notification.params);
          }
        } catch (err) {
          error('failed to record codex event', err);
        }
        if (typeof previousHandler === 'function') {
          try {
            previousHandler(notification);
          } catch (err) {
            error('fallback handler error', err);
          }
        }
      };

      const started = performance.now();
      try {
        const options = {
          timeout: this.options.requestTimeoutMs,
          maxTotalTimeout: this.options.maxTotalTimeoutMs,
          resetTimeoutOnProgress: true,
        };
        if (extra?.signal instanceof AbortSignal) {
          options.signal = extra.signal;
        }
        const result = await client.callTool({ name, arguments: args }, undefined, options);
        const durationMs = performance.now() - started;
        return { result, events, durationMs };
      } catch (err) {
        try {
          await client.close();
        } catch (closeErr) {
          warn('error during client close after failure', closeErr);
        }
        if (this.transport) {
          try {
            await this.transport.close();
          } catch (closeErr) {
            warn('error during transport close after failure', closeErr);
          }
        }
        this.client = null;
        this.transport = null;
        throw err;
      } finally {
        client.fallbackNotificationHandler = previousHandler;
      }
    };
    return this.withLock(run);
  }

  async startSession(input, extra) {
    const { prompt, ...rest } = input;
    if (!prompt || !prompt.trim()) {
      throw new Error('codex_prompt_required');
    }
    const payload = { prompt: String(prompt), ...rest };
    const { result, events, durationMs } = await this.runToolCall('codex', payload, extra);
    const summary = summarizeEvents(events);
    if (!summary.sessionId) {
      throw new Error('codex_session_id_missing');
    }
    const message = extractFirstText(result) || summary.agentMessage || '';
    return {
      conversationId: summary.sessionId,
      message,
      summary,
      durationMs,
    };
  }

  async continueSession(input, extra) {
    const { conversationId, prompt, ...rest } = input;
    if (!conversationId || !conversationId.trim()) {
      throw new Error('codex_conversation_id_required');
    }
    if (!prompt || !prompt.trim()) {
      throw new Error('codex_prompt_required');
    }
    const payload = { conversationId: String(conversationId), prompt: String(prompt), ...rest };
    const { result, events, durationMs } = await this.runToolCall('codex-reply', payload, extra);
    const summary = summarizeEvents(events, { fallbackConversationId: conversationId });
    const message = extractFirstText(result) || summary.agentMessage || '';
    return {
      conversationId: conversationId,
      message,
      summary,
      durationMs,
    };
  }

  async execSession(input, extra) {
    const { prompt, output_schema: outputSchema, metadata } = input || {};
    if (!prompt || !prompt.trim()) {
      throw new Error('codex_prompt_required');
    }

    const started = performance.now();
    const contextualPrefix = buildPromptPreface(metadata);
    const fullPrompt = contextualPrefix ? `${contextualPrefix}\n\n${prompt}` : prompt;

    let tempDir;
    let schemaPath;
    try {
      const execArgs = ['exec', '--json', '-c', 'mcp_servers={}'];

      // Keep exec sandboxed/read-only by default to match our other tools.
      execArgs.push('--sandbox', 'read-only');

      if (outputSchema !== undefined) {
        tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'codex-schema-'));
        schemaPath = path.join(tempDir, 'schema.json');
        const schemaString =
          typeof outputSchema === 'string'
            ? outputSchema
            : JSON.stringify(outputSchema, null, 2);
        await fs.writeFile(schemaPath, schemaString, 'utf8');
        execArgs.push('--output-schema', schemaPath);
      }

      execArgs.push(fullPrompt);

      const stdoutChunks = [];
      const stderrChunks = [];

      const child = spawn(DEFAULT_COMMAND, execArgs, {
        env: process.env,
        stdio: ['ignore', 'pipe', 'pipe'],
      });

      child.stdout.on('data', (chunk) => stdoutChunks.push(chunk));
      child.stderr.on('data', (chunk) => stderrChunks.push(chunk));

      const exitCode = await new Promise((resolve, reject) => {
        child.on('error', reject);
        child.on('close', resolve);
      });

      const stdout = Buffer.concat(stdoutChunks).toString('utf8');
      const stderr = Buffer.concat(stderrChunks).toString('utf8');

      if (exitCode !== 0) {
        throw new Error(`codex exec failed (code ${exitCode}): ${stderr || stdout}`);
      }

      const parsedEvents = parseCodexExecOutput(stdout);
      const summary = summarizeEvents(parsedEvents);
      const message = getFinalMessage(parsedEvents) || '';
      const structuredContent = parseJsonSafely(message);
      const durationMs = performance.now() - started;

      return {
        conversationId: null,
        message,
        summary,
        durationMs,
        structuredContent,
        raw: {
          events: parsedEvents,
          stderr: stderr || null,
        },
      };
    } finally {
      try {
        if (schemaPath) await fs.rm(schemaPath, { force: true });
        if (tempDir) await fs.rm(tempDir, { recursive: true, force: true });
      } catch (cleanupError) {
        warn('failed to cleanup exec schema artifacts', cleanupError);
      }
    }
  }

  async shutdown() {
    if (this.client) {
      try {
        await this.client.close();
      } catch (err) {
        warn('error closing client', err);
      }
      this.client = null;
    }
    if (this.transport) {
      try {
        await this.transport.close();
      } catch (err) {
        warn('error closing transport', err);
      }
      this.transport = null;
    }
  }
}

const singleton = new CodexBridge();

export function getCodexBridge() {
  return singleton;
}

export async function shutdownCodexBridge() {
  await singleton.shutdown();
}

export function formatStructuredResult({ conversationId, message, summary, durationMs }) {
  const timeline = summary.timeline.filter(Boolean);
  const trimmedTimeline = timeline.length > 200 ? timeline.slice(timeline.length - 200) : timeline;
  return {
    conversationId,
    response: {
      text: message,
      reasoning: summary.reasoning || null,
    },
    session: {
      model: summary.model,
      reasoningEffort: summary.reasoningEffort,
      rolloutPath: summary.rolloutPath,
    },
    tokenUsage: summary.tokenUsage || null,
    rateLimits: summary.rateLimits || null,
    timeline: trimmedTimeline,
    durationMs,
  };
}

function buildPromptPreface(metadata) {
  if (!metadata || typeof metadata !== 'object') return '';
  const entries = Object.entries(metadata).filter(([, value]) => value !== undefined);
  if (!entries.length) return '';
  const lines = entries.map(([key, value]) => `- ${key}: ${formatMetadataValue(value)}`);
  return `Context:\n${lines.join('\n')}`;
}

function formatMetadataValue(value) {
  if (value === null) return 'null';
  if (typeof value === 'object') {
    try {
      return JSON.stringify(value);
    } catch {
      return String(value);
    }
  }
  return String(value);
}

function parseCodexExecOutput(stdout) {
  const events = [];
  for (const line of stdout.split(/\r?\n/)) {
    const trimmed = line.trim();
    if (!trimmed.startsWith('{')) continue;
    try {
      const parsed = JSON.parse(trimmed);
      if (parsed && typeof parsed === 'object') {
        events.push(parsed);
      }
    } catch (err) {
      warn('failed to parse codex exec line', { line: trimmed, err: err?.message });
    }
  }
  return events;
}

function getFinalMessage(events) {
  for (let i = events.length - 1; i >= 0; i -= 1) {
    const msg = events[i]?.msg;
    if (msg?.type === 'agent_message') {
      return msg.message ?? '';
    }
  }
  return '';
}

function parseJsonSafely(text) {
  if (!text || typeof text !== 'string') return null;
  try {
    return JSON.parse(text);
  } catch {
    return null;
  }
}

export default singleton;
